{"posts":[{"title":"git的常用操作","text":"1.1 配置用户名和邮箱12git config --global user.name &quot;&quot;git config --global user.email &quot;&quot; 1.2 强制添加被忽略文件添加一个被.gitignore文件忽略的文件，可以添加-f参数 1git add -f App.class 1.3 暂存stash​ 当您想记录工作目录和索引的当前状态，但又想返回一个干净的工作目录时，请使用git stash。该命令将保存本地修改，并恢复工作目录以匹配头部提交。 1234567891011121314151617181920# 保存当前未commit的代码git stash# 保存当前未commit的代码并添加备注git stash save &quot;备注的内容&quot;# 列出stash的所有记录git stash list# 删除stash的所有记录git stash clear# 应用最近一次的stashgit stash apply# 应用最近一次的stash，随后删除该记录git stash pop# 删除最近的一次stashgit stash drop 1.4 GIT修改commit信息12345678# 提交暂存区到仓库区git commit -m [message]命令：git commit --amend场景一：git commit -m 提交之后，发现-m的说明文字写的有问题，想要重新写一次，也就是想撤销上次的提交动作，重新提交一次场景二：提交代码时，发现提交的文件中需要修改或者还有文件未修改。 重新提交是在日志看不到操作记录的。使用一次新的commit，替代上一次提交如果代码没有任何新变化，则用来改写上一次commit的提交信息 1.5 版本回退​ 回退你已提交的 commit，并将 commit 的修改内容放回到暂存区。 12345678# 恢复最近一次 commitgit reset --soft HEAD^git reset --hard HEAD^ #回退到上一个版本git reset --hard HEAD^^ #回滚到上上一版本：git reset --hard cb926e7 #回退到具体某个版git reset --keep [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 对于上面的场景，就可以再次修改重新提交，保持干净的 commit 记录,在 reset --soft 指定 commit 号时，会将该 commit 到最近一次 commit 的所有修改内容全部恢复，而不是只针对该 commit。 1.6 删除git上的文件，如node_modules12345// node_modules 你要删除的其他文件// master 提交的分支git rm -r --cached node_modulesgit commit -m 'node_modules'git push origin master 1.7 tag标签的使用123456789101112131415git tag # 列出当前仓库的所有标签git tag -l 'v0.1.*' # 搜索符合当前模式的标签 git tag v0.2.1-light # 创建轻量标签git tag -a v0.2.1 -m '0.2.1版本' # 创建附注标签 git checkout [tagname] # 切换到标签git show v0.2.1 # 查看标签版本信息 git tag -d v0.2.1 # 删除标签git tag -a v0.2.1 9fbc3d0 # 补打标签 git push origin v0.1.2 # 将v0.1.2标签提交到git服务器git push origin –tags # 将本地所有标签一次性提交到git服务器git tag # 查看当前分支下的标签 1.8 分支1234567891011121314151617181920212223242526272829git branch # 列出所有本地分支git branch -r # 列出所有远程分支git branch -a # 列出所有本地分支和远程分支git branch [branch-name] # 新建一个分支，但依然停留在当前分支git checkout -b [branch] # 新建一个分支，并切换到该分支git branch [branch] [commit] # 新建一个分支，指向指定commitgit branch --track [branch] [remote-branch] # 新建一个分支，与指定的远程分支建立追踪关系git checkout [branch-name] # 切换到指定分支，并更新工作区git checkout - # 切换到上一个分支git branch --set-upstream [branch] [remote-branch] # 建立追踪关系，在现有分支与指定的远程分支之间git merge [branch] # 合并指定分支到当前分支git cherry-pick [commit] # 选择一个commit，合并进当前分支git branch -d [branch-name] # 删除分支# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 报错解决 Cannot do a soft reset in the middle of a merge1git merge --abort","link":"/2023/11/19/git/git%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"title":"大文件切片上传","text":"完整代码获取 实现思路： 切片上传是指将一个大文件切割为若干个小文件，分为多个请求依次上传，后台再将文件碎片拼接为一个完整的文件。 实现的功能： 文件切片上传 多线程处理文件切片任务 上传暂停 断点续传 1.文件切片选择文件，并且对文件的类型进行校验，限制文件上传的类型，设置每个切片的大小，进行文件切片 文件切片和核心是使用 Blob 对象的 slice 方法 对文件的处理离不开File对象。File提供了文件的相关信息，它继承于Blob对象，并添加了name(文件名)、lastModified(最后一次修改的时间戳)等属性。 12345678910111213141516171819202122232425262728293031323334// 切片大小 const SIZE = 10 * 1024 * 1024; let hashPercentage = ref(0); //生成hash进度 let fakeUploadPercentage = ref(0); //上传进度 let data = ref([]); let XMLHttpRequestList = ref([]); const reset = () =&gt; { hashPercentage.value = 0; fakeUploadPercentage.value = 0; };/** * 选择文件 */const handleFileChange = (e) =&gt; { const [file] = e.target.files; if (!file) return; if (!allowType[file.type]) { console.log(&quot;不支持该类型文件上传！&quot;); return; } container.file = file;};// 生成文件切片const createFileChunk = (file, size = SIZE) =&gt; { const fileChunkList = []; let cur = 0; while (cur &lt; file.size) { fileChunkList.push({ file: file.slice(cur, cur + size) }); cur += size; } return fileChunkList;}; 2. 多线程文件切片 下面使用 spark-md5 库来根据文件内容计算出文件的 MD5 值，MD5值是用来传给后端用于秒传功能和分块上传的标识。 浏览器执行环境是单线程的，一旦出现【主线程】耗时操作，就会造成浏览器卡死，用户点击没响应等情况，问价切片可能造成页面长时间没有响应，用户不能进行页面操作，用户的使用感受会大大降低，这时候使用workers独立于主线程运行的子线程。可以将一些可能会阻塞主线程的文件切片操作，丢在 Worker 里去单独执行。 使用线程需要注意： 同源限制：创建 worker 线程的时候需要分配一个 JS 文件，该文件必须是同源的，且不能是本地文件； 环境隔离：worker 线程所在的上下文环境与主线程不一样，无法读取网页的 DOM 对象，全局对象不再是 window，可以通过 this 或 self 访问。 通信受限：主线程和 worker 线程不能直接通信，通过 postMessage 方法进行消息传递。 前端代码为： 12345678910111213141516// 生成文件 hash const calculateHash = (fileChunkList) =&gt; { return new Promise((resolve) =&gt; { container.worker = new Worker(&quot;/hash.js&quot;); //发送信息到worker进程 container.worker.postMessage({ fileChunkList }); // 监听接收worker进程信息 container.worker.onmessage = (e) =&gt; { const { percentage, hash } = e.data; hashPercentage.value = percentage; if (hash) { resolve(hash); } }; }); }; 3. 上传前文件校验在文件切片开始上传之前，需要将切片的信息传递到后端进行校验，判断该文件是否是上传过的，如果上传过的话实现秒传，后端代码为： 123456789101112131415161718192021// 验证是否已上传/已上传切片下标 async handleVerifyUpload(req, res) { const data = await resolvePost(req); const { fileHash, filename } = data; const ext = extractExt(filename); const filePath = path.resolve(UPLOAD_DIR, `${fileHash}${ext}`); if (fse.existsSync(filePath)) { res.end( JSON.stringify({ shouldUpload: false }) ); } else { res.end( JSON.stringify({ shouldUpload: true, uploadedList: await createUploadedList(fileHash) }) ); } } 1234567891011121314151617181920212223242526272829303132const handleUpload = async () =&gt; { if (!container.file) return; reset(); // 文件切片 const fileChunkList = createFileChunk(container.file); console.log(fileChunkList, &quot;fileChunkList&quot;); // 生成文件hash container.hash = (await calculateHash(fileChunkList)) as string; // 验证 const { shouldUpload, uploadedList } = await verifyUpload( container.file.name, container.hash ); if (!shouldUpload) { return; } data.value = fileChunkList.map(({ file }, index) =&gt; ({ fileHash: container.hash, index, hash: container.hash + &quot;-&quot; + index, chunk: file, size: file.size, percentage: uploadedList.includes(index) ? 100 : 0, })); await uploadChunks(uploadedList);}; 4. 文件上传文件校验完毕之后，正式进行文件的上传： 旧版的 XMLHttpRequest 是不支持显示进度的，升级为 Level 2 之后，有一个 progress 事件，用来返回进度信息。这也是为什么该场景下推荐使用 xhr ，而不使用 fetch 的原因。fetch 不提供相关的接口，我们无法获得文件的上传进度。 我们可以通过 onprogress 事件来实时显示进度，默认情况下这个事件每 50ms 触发一次。需要注意的是，上传过程和下载过程触发的是不同对象的 onprogress 事件：上传触发的是 xhr.upload 对象的 onprogress 事件，下载触发的是 xhr对象的 onprogress 事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 // 上传切片 const uploadChunks = async (uploadedList = []) =&gt; { const requestList = data.value .filter(({ hash }) =&gt; !uploadedList.includes(hash)) .map(({ chunk, hash, index }) =&gt; { const formData = new FormData(); formData.append(&quot;chunk&quot;, chunk); formData.append(&quot;hash&quot;, hash); formData.append(&quot;filename&quot;, container.file.name); formData.append(&quot;fileHash&quot;, container.hash); return { formData, index }; }) .map(({ formData, index }) =&gt; request({ url: &quot;http://localhost:3000&quot;, data: formData, onProgress: createProgressHandler(data.value[index]), requestList: XMLHttpRequestList.value, }) ); await Promise.all(requestList); // 之前上传的切片数量 + 本次上传的切片数量 = 所有切片数量时合并切片 if (uploadedList.length + requestList.length === data.value.length) { await mergeRequest(); } }; // 保存每个 chunk 的进度数据 const createProgressHandler = (item) =&gt; { return (e) =&gt; { item.percentage = parseInt(String((e.loaded / e.total) * 100)); }; };// 进度 const uploadPercentage = computed(() =&gt; { if (!data.value.length) return 0; const loaded = data.value .map((item) =&gt; item.size * item.percentage) .reduce((acc, cur) =&gt; acc + cur); return parseInt((loaded / container.file.size).toFixed(2)); }); watch(uploadPercentage, (now) =&gt; { if (now &gt; fakeUploadPercentage.value) { fakeUploadPercentage.value = now; } }); 后端代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243async handleFormData(req, res) { const multipart = new multiparty.Form(); multipart.parse(req, async (err, fields, files) =&gt; { if (err) { console.error(err); res.status = 500; res.end(&quot;process file chunk failed&quot;); return; } const [chunk] = files.chunk; const [hash] = fields.hash; const [fileHash] = fields.fileHash; const [filename] = fields.filename; const filePath = path.resolve( UPLOAD_DIR, `${fileHash}${extractExt(filename)}` ); const chunkDir = getChunkDir(fileHash); const chunkPath = path.resolve(chunkDir, hash); // 文件存在直接返回 if (fse.existsSync(filePath)) { res.end(&quot;file exist&quot;); return; } // 切片存在直接返回 if (fse.existsSync(chunkPath)) { res.end(&quot;chunk exist&quot;); return; } // 切片目录不存在，创建切片目录 if (!fse.existsSync(chunkDir)) { await fse.mkdirs(chunkDir); } // fs-extra 的 rename 方法 windows 平台会有权限问题 await fse.move(chunk.path, path.resolve(chunkDir, hash)); res.end(&quot;received file chunk&quot;); });} 5. 文件合并文件上传完毕之后，通知后端进行文件合并操作： 123456789101112131415// 通知服务端合并切片 const mergeRequest = async () =&gt; { await request({ url: &quot;http://localhost:3000/merge&quot;, headers: { &quot;content-type&quot;: &quot;application/json&quot;, }, data: JSON.stringify({ size: SIZE, fileHash: container.hash, filename: container.file.name, }), }); console.log(&quot;upload success, check /target directory&quot;); }; 后端代码为： 1234567891011121314151617181920212223242526272829303132333435363738// 合并切片 async handleMerge(req, res) { const data = await resolvePost(req); const { fileHash, filename, size } = data; const ext = extractExt(filename); const filePath = path.resolve(UPLOAD_DIR, `${fileHash}${ext}`); await mergeFileChunk(filePath, fileHash, size); res.end( JSON.stringify({ code: 0, message: &quot;file merged success&quot; }) ); }// 合并切片const mergeFileChunk = async (filePath, fileHash, size) =&gt; { const chunkDir = getChunkDir(fileHash); const chunkPaths = await fse.readdir(chunkDir); // 根据切片下标进行排序 // 否则直接读取目录的获得的顺序会错乱 chunkPaths.sort((a, b) =&gt; a.split(&quot;-&quot;)[1] - b.split(&quot;-&quot;)[1]); // 并发写入文件 await Promise.all( chunkPaths.map((chunkPath, index) =&gt; pipeStream( path.resolve(chunkDir, chunkPath), // 根据 size 在指定位置创建可写流 fse.createWriteStream(filePath, { start: index * size }) ) ) ); // 合并后删除保存切片的目录 fse.rmdirSync(chunkDir);}; 6. 上传暂停暂停文件的上传： 1234567const resetData = async () =&gt; { XMLHttpRequestList.value.forEach((xhr) =&gt; xhr.abort()); XMLHttpRequestList.value = []; if (container.worker) { container.worker.onmessage = null; } }; 7. 继续上传1234567const handleResume = async () =&gt; { const { uploadedList } = await verifyUpload( container.file.name, container.hash ); await uploadChunks(uploadedList); };","link":"/2024/03/04/vue/%E5%88%87%E7%89%87%E4%B8%8A%E4%BC%A0/"},{"title":"实现一个WebSocket即时通讯聊天","text":"整体架构完整代码获取 前端：Vue搭建+websock客户端 后端：nodeJs+websock服务端 ​ WebSocket 是一种支持双向通信的协议，通过在客户端和服务器之间建立持久连接，可以实现实时的双向数据传输。WebSocket 适用于需要实时性和低延迟的应用，例如在线聊天应用或实时游戏。 ​ WebSocket是另一种网络协议，但没有完全脱离HTTP，握手阶段采用的就是HTTP协议，这么做的好处就是不易被屏蔽，能通过各种HTTP代理服务器； ​ WebSocket最大的特点就是服务器可以主动向客户端推送消息，当然，客户端也可以主动的向服务器发送消息。而普通的HTTP协议只能由客户端向服务器发送，服务器根据内容进行返回。 WebSocket有以下特点： 是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。 HTTP长连接中，每次数据交换除了真正的数据部分外，服务器和客户端还要大量交换HTTP header，信息交换效率很低。Websocket协议通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据。 前端实现：输入用户名加入聊天室 点击用户头像进行私聊： 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div class='chat'&gt; &lt;mainContainer&gt; &lt;Contacts :curUser=&quot;curUser&quot; :userList=&quot;userList&quot; :curUserId=&quot;curUser.id&quot; :chatUser=&quot;chatUser&quot; @click-user=&quot;handleClickAvatar&quot; &gt;&lt;/Contacts&gt; &lt;!-- 群聊 --&gt; &lt;publicChat v-if=&quot;chatType == 'qunliao'&quot; :chatData=&quot;chatData&quot; @send=&quot;handleSend&quot; @click-user=&quot;handleClickAvatar&quot; &gt;&lt;/publicChat&gt; &lt;!-- 私聊 --&gt; &lt;personalChat v-else :chatData=&quot;userChatData.get(chatUserId) ?? []&quot; :chatUser=&quot;chatUser&quot; @send=&quot;handleSendUser&quot; &gt;&lt;/personalChat&gt; &lt;/mainContainer&gt; &lt;JoinModel @join=&quot;handleJoin&quot;/&gt; &lt;/div&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154import { io } from 'socket.io-client'import { reactive, ref } from 'vue'export default () =&gt; { // 创建 socket 实例 const socket = io('ws://localhost:5433') interface ChatDataItem { type: 'your' | 'me' | 'tips' id: string name?: string content: string avatar?: string userId?: string } // 监听 join const handleJoin = (e:any) =&gt; { socket.emit('join', Object.assign({}, e)) } const curUser = reactive({ //当前登陆的用户信息 name: '', avatar: '', id: '', }) // 获取当前加入群聊信息 socket.on('joined', (e: typeof curUser) =&gt; { curUser.avatar = e.avatar curUser.id = e.id curUser.name = e.name }) const userList = ref(new Map()) //在线用户 const chatData = ref&lt;ChatDataItem[]&gt;([]) //群聊的信息 // 监听 welcome socket.on('welcome', ({ name, uList }) =&gt; { uList.forEach((item: any[]) =&gt; { const [id, value] = item userList.value.set(id, value) }) chatData.value.push({ type: 'tips', id: Math.random().toString().split('.')[1].slice(0, 10), content: '欢迎' + name + '加入群聊~', }) }) // 群聊发送消息 const handleSend = (v: string) =&gt; { const obj = { id: Math.random().toString().split('.')[1].slice(0, 10), name: curUser.name, avatar: curUser.avatar, content: v, userId: curUser.id, } // 在 chatData 中新增一条数据，表示自己发送的 const type: 'me' = 'me' chatData.value.push(Object.assign({}, { type }, obj)) // 发出send事件，将消息发送出去 socket.emit('send', obj) } // 监听群聊消息的广播 socket.on('message', (e: any) =&gt; { const msg = Object.assign({}, e, { type: 'your' }) as ChatDataItem chatData.value.push(msg) }) const chatUserId = ref('') //私聊用户id const chatUser = ref(null) //私聊用户信息 const chatType = ref('qunliao') //聊天类型 // 点击用户头像私聊 const handleClickAvatar = (e:any) =&gt; { if (e.id === curUser.id) { return } if(e.name == undefined){ chatType.value = 'qunliao' return } chatType.value = 'siliao' chatUserId.value = e.id //私聊对象id chatUser.value = e //私聊对象 const u = userList.value.get(chatUserId.value) // 点击头像去掉表示已读去掉红点 if (u) { u.new = false } } const userChatData = ref&lt;Map&lt;string, ChatDataItem[]&gt;&gt;(new Map()) // 私聊发送消息 const handleSendUser = (v: string) =&gt; { const obj = { id: Math.random().toString().split('.')[1].slice(0, 10), name: curUser.name, avatar: curUser.avatar, content: v, userId: curUser.id, sendUserId: chatUserId.value, } // 在 userChatData 中新增一条数据，表示自己发送的 const type: 'me' = 'me' if (!userChatData.value.has(chatUserId.value)) { userChatData.value.set(chatUserId.value, []) } const _chatData = userChatData.value.get(chatUserId.value) ?? [] _chatData.push(Object.assign({}, { type }, obj)) // 发出send事件，将消息发送出去 socket.emit('send-user', obj) } // 私聊监听接受消息 socket.on('message-user', (e: any) =&gt; { const msg = Object.assign({}, e, { type: 'your' }) as ChatDataItem const sendId = e.userId if (!userChatData.value.has(sendId)) { userChatData.value.set(sendId, []) } const chatData = userChatData.value.get(sendId) ?? [] chatData.push(msg) // 给发送消息的id标记新信息 const u = userList.value.get(sendId) if (u) { u.new = true } }) // 监听退出 socket.on('quit', (id: string) =&gt; { const user = userList.value.get(id) userList.value.delete(id) chatData.value.push({ type: 'tips', id: Math.random().toString().split('.')[1].slice(0, 10), content: user?.name + '退出群聊~', }) }) return{ handleJoin, curUser, userList, chatType, // 群聊 ...{chatData , handleSend , handleClickAvatar}, // 私聊 ...{userChatData , chatUserId, chatUser , handleSendUser}, }} Node后端实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546import { Server } from 'socket.io'// 开启cors跨域const io = new Server(5433, { cors: true })let userList = new Map() io.on('connection', socket =&gt; { //实例在连接和重新连接时触发 // 监听加入用户加入 socket.on('join', e =&gt; { userList.set(socket.id, e) // 加入成功后返回加入成功的事件 socket.emit('joined', Object.assign({}, e, { id: socket.id })) const uList = [...userList.entries()] // 触发广播 socket.broadcast.emit('welcome', { ...e, uList, }) // 自己展示加入的信息 socket.emit('welcome', { ...e, uList, }) }) // 监听消息发送 socket.on('send', e =&gt; { // 接受到消息给他广播出去 所有连接到服务器的客户端都会受到广播的信息 socket.broadcast.emit('message', e) }) // 监听私聊消息的发送 socket.on('send-user', e =&gt; { const sendUserId = e.sendUserId socket.to(sendUserId).emit('message-user', e) }) // 用户离开 socket.on('disconnecting', () =&gt; { //socket失去链接时触发，包括关闭浏览器，主动断开，掉线等情况 const bool = userList.delete(socket.id) // 如果有用户离开，在进行广播（因为只打开页面不进入关闭页面也会触发这个事件） bool &amp;&amp; socket.broadcast.emit('quit', socket.id) }) })console.log('服务启动..');","link":"/2023/08/04/vue/%E8%81%8A%E5%A4%A9%E5%AE%A4/"}],"tags":[{"name":"git","slug":"git","link":"/tags/git/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"NodeJs","slug":"NodeJs","link":"/tags/NodeJs/"},{"name":"Element UI","slug":"Element-UI","link":"/tags/Element-UI/"},{"name":"Vite","slug":"Vite","link":"/tags/Vite/"},{"name":"Node","slug":"Node","link":"/tags/Node/"},{"name":"WebSocket","slug":"WebSocket","link":"/tags/WebSocket/"}],"categories":[{"name":"git","slug":"git","link":"/categories/git/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"}],"pages":[{"title":"","text":"个人简介 💪💪💪💪💪💪 冲鸭！！！！ 坚信代码改变世界!!","link":"/about/index.html"},{"title":"","text":".empty{ height: 145px; }","link":"/about/style.css"}]}